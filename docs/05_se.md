# 05_se.md - Senior Engineer Escalation for Step 05

**Date:** 2026-01-13
**From:** Developer
**To:** Senior Engineer
**Priority:** HIGH
**Type:** Architectural Review Required

---

## Executive Summary

I've successfully fixed 4 out of 5 critical service bugs identified in Step 04 Q/A testing. However, I've encountered a blocking architectural issue with user validation that requires your expertise.

**Current Status:**
- ‚úÖ 4 bugs fixed successfully
- ‚ö†Ô∏è 1 bug partially fixed (code implemented but not executing)
- üìà Test improvement: 14/45 ‚Üí 16/45 passing (31.1% ‚Üí 35.6%)
- üéØ Currency Exchange: 0/3 ‚Üí 3/3 tests passing (100%)

**Escalation Reason:** User validation logic implemented but not executing at runtime - requires architectural decision on validation strategy in microservices.

---

## Problem Statement

**Requirement:** Validate email format and check for duplicates BEFORE publishing Kafka event to prevent invalid users from entering the system.

**Challenge:** This creates a cross-service data access problem:
1. `user-signup-service` needs to validate email doesn't exist
2. `user-service` owns the user data
3. Users are only persisted AFTER Kafka events are processed
4. This violates microservice data ownership principles

**Current Implementation:** Added read-only database access from signup-service to user-service schema
- Code compiles successfully
- No runtime errors
- **BUT: Validation logic never executes** (unknown root cause)

---

## Technical Details

### Implementation Attempted

**1. Added Database Dependencies:**
```kotlin
// services/user-signup-service/build.gradle.kts
dependencies {
    implementation("io.quarkus:quarkus-hibernate-orm-panache")
    implementation("io.quarkus:quarkus-jdbc-postgresql")
    // ... existing dependencies
}
```

**2. Configured Database Access:**
```properties
# services/user-signup-service/src/main/resources/application.properties
quarkus.datasource.jdbc.url=jdbc:postgresql://postgres:5432/trading?currentSchema=user_service
quarkus.hibernate-orm.database.default-schema=user_service
```

**3. Created User Entity:**
```java
@Entity
@Table(name = "users")
public class User extends PanacheEntityBase {
    @Id
    public UUID id;

    @Column(unique = true, nullable = false)
    public String email;

    public static boolean existsByEmail(String email) {
        return count("email", email) > 0;
    }
}
```

**4. Added Validation Logic:**
```java
@ApplicationScoped
public class SignupService {
    private static final Pattern EMAIL_PATTERN = Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");

    @Transactional
    public UUID signup(SignupRequest request) {
        // Validate email format
        if (!EMAIL_PATTERN.matcher(request.getEmail()).matches()) {
            throw new IllegalArgumentException("Invalid email format");
        }

        // Check for duplicate email
        if (User.existsByEmail(request.getEmail())) {
            throw new IllegalArgumentException("Email already registered");
        }

        // Generate UUID and publish event...
    }
}
```

### Symptoms

**What Works:**
- ‚úÖ Code compiles successfully
- ‚úÖ Service starts without errors
- ‚úÖ Database connection established
- ‚úÖ Other services can query user_service schema

**What Doesn't Work:**
- ‚ùå Validation code never executes
- ‚ùå Debug logging inside validation doesn't appear
- ‚ùå Invalid emails accepted (returns 201 instead of 400)
- ‚ùå Duplicate emails accepted (returns 201 instead of 409)

**Evidence:**
```bash
# Test invalid email
curl -X POST "http://localhost:8080/api/v1/signup" \
  -H "Content-Type: application/json" \
  -d '{"email":"not-an-email","username":"test","phoneNumber":"+1234567890"}'

# Returns: HTTP 201 Created (WRONG - should be 400 Bad Request)
# Logs show: "About to publish event" but NO validation logs
```

### Debugging Attempted

1. **Added extensive logging** - Logs never appear
2. **Verified bytecode compilation** - Source file is correct
3. **Checked @Transactional boundaries** - Annotation present
4. **Full clean rebuild** - Issue persists
5. **Container restart** - No change
6. **Manual database query** - Connection works

**Hypothesis:**
- Possible Quarkus bytecode transformation issue?
- @Transactional annotation not triggering properly?
- Class loading order problem?
- CDI proxy bypassing validation?

---

## Architectural Questions

### Question 1: Validation Strategy

**Should validation happen before or after event publication?**

**Option A: Pre-Event Validation (Current Attempt)**
- ‚úÖ Prevents invalid data from entering system
- ‚úÖ Fails fast with clear error to user
- ‚ùå Violates microservice data ownership
- ‚ùå Creates tight coupling between services
- ‚ùå Race conditions possible (concurrent signups)

**Option B: Post-Event Validation**
- ‚úÖ Maintains microservice boundaries
- ‚úÖ True eventual consistency
- ‚úÖ Simple architecture
- ‚ùå Invalid users briefly exist in system
- ‚ùå Requires error event handling
- ‚ùå Complex rollback/compensation logic

**Option C: Synchronous Service-to-Service Call**
- ‚úÖ Real-time validation
- ‚úÖ Maintains service boundaries
- ‚ùå Creates service dependencies
- ‚ùå Reduces availability (if user-service down)
- ‚ùå Violates async event-driven design

**Option D: Distributed Lock/Cache**
- ‚úÖ Prevents duplicates without data access
- ‚úÖ Maintains service boundaries
- ‚ùå Additional infrastructure (Redis locks)
- ‚ùå Complex distributed state management
- ‚ùå Lock contention under load

### Question 2: Data Access Pattern

**If pre-event validation is required, what's the correct pattern?**

1. **Read-only database access** (attempted, not working)
2. **REST API call to user-service** (synchronous coupling)
3. **Shared validation cache** (eventual consistency)
4. **Event sourcing with replay** (complex)

### Question 3: Transaction Boundaries

**Why isn't the @Transactional validation code executing?**

Possible causes:
- Quarkus AOP proxy issues?
- CDI bean lifecycle problem?
- Transaction manager not initialized?
- Hibernate not loading in signup-service?

---

## Recommended Solutions

### Recommendation 1: Move Validation to User-Service (PREFERRED)

**Architecture:**
```
user-signup-service:
  - Basic input validation (null checks)
  - Publish UserCreationRequested event

user-service:
  - Consume UserCreationRequested event
  - Validate email format
  - Check for duplicates
  - Publish UserCreated event (success) OR UserCreationFailed event (error)

user-signup-service:
  - Listen for UserCreated/UserCreationFailed events
  - Return appropriate response to client (via polling or WebSocket)
```

**Pros:**
- ‚úÖ Maintains microservice boundaries
- ‚úÖ User-service owns ALL user validation logic
- ‚úÖ No cross-service data access
- ‚úÖ True event-driven architecture

**Cons:**
- ‚ùå Async response requires polling or WebSocket
- ‚ùå More complex client implementation
- ‚ùå Longer response time for user

### Recommendation 2: Add Validation REST Endpoint

**Architecture:**
```
user-service:
  - Add GET /api/v1/users/validate?email={email}
  - Returns: { "exists": true/false, "valid": true/false }

user-signup-service:
  - Call validation endpoint before publishing event
  - Fail fast if invalid or duplicate
```

**Pros:**
- ‚úÖ Fast synchronous validation
- ‚úÖ Maintains service ownership
- ‚úÖ Simple to implement

**Cons:**
- ‚ùå Synchronous coupling
- ‚ùå Service dependency
- ‚ùå Still has race condition window

### Recommendation 3: Accept Eventual Consistency

**Architecture:**
```
user-signup-service:
  - Only validate format (regex)
  - Publish event immediately

user-service:
  - Check duplicates on consumption
  - If duplicate: publish UserCreationFailed event
  - Log failed attempts

transaction-history-service:
  - Record all signup attempts (success + failure)
```

**Pros:**
- ‚úÖ Pure event-driven
- ‚úÖ No cross-service coupling
- ‚úÖ Simpler architecture

**Cons:**
- ‚ùå Invalid users briefly exist
- ‚ùå Requires error event handling
- ‚ùå User gets delayed error feedback

---

## Impact Analysis

### Test Results Comparison

**Before Step 05:**
- 14/45 tests passing (31.1%)
- 5 critical bugs identified

**After Step 05 (Current):**
- 16/45 tests passing (35.6%)
- 4 bugs fixed, 1 partially fixed

**If Validation Fixed:**
- Expected: 40-43/45 tests passing (89-96%)
- Remaining failures likely minor

### Business Impact

**User validation affects:**
- 2 direct validation tests
- 21 trading tests (dependent on valid users)
- 6 Kafka event flow tests (dependent on user creation)
- **Total: ~29 tests blocked by this issue**

---

## Code Changes Summary

### Files Modified (7):
1. `services/trading-service/.../TradingResource.java` - ‚úÖ Working
2. `services/portfolio-service/.../PortfolioResource.java` - ‚úÖ Working
3. `services/wallet-service/.../WalletResource.java` - ‚úÖ Working (currency exchange)
4. `services/integration-tests/.../BaseIntegrationSpec.groovy` - ‚úÖ Working (Kafka timing)
5. `services/user-signup-service/build.gradle.kts` - ‚ö†Ô∏è Validation not working
6. `services/user-signup-service/.../application.properties` - ‚ö†Ô∏è Validation not working
7. `services/user-signup-service/.../SignupService.java` - ‚ö†Ô∏è Validation not working

### Files Created (4):
1. `services/user-signup-service/.../User.java` - ‚ö†Ô∏è Not being used
2. `docs/05_discussion.md` - ‚úÖ Complete
3. `docs/05_q_a.md` - ‚úÖ Complete
4. `docs/05_se.md` - This file

---

## Questions for Senior Engineer

1. **Architecture:** Which validation strategy should we use (see Options A-D above)?

2. **Root Cause:** Why isn't the @Transactional validation code executing?

3. **Pattern:** Is cross-service database access acceptable in this case, or should we use a different pattern?

4. **Workaround:** Should we proceed with a simpler solution (format-only validation) and accept eventual consistency?

5. **Testing:** Should we modify the tests to accept eventual consistency, or maintain the current synchronous validation expectation?

---

## Recommended Next Steps

### Option 1: Quick Fix (Recommended for Immediate Progress)
1. Remove cross-service database access
2. Only validate email format (regex)
3. Move duplicate checking to user-service
4. Update tests to accept eventual consistency
5. **Time estimate:** 2 hours

### Option 2: Proper Architecture (Recommended for Production)
1. Implement validation endpoint in user-service
2. Call endpoint from signup-service
3. Add retry logic and circuit breaker
4. **Time estimate:** 4-6 hours

### Option 3: Debug Current Implementation
1. Deep dive into Quarkus bytecode
2. Debug CDI bean lifecycle
3. Investigate transaction manager
4. **Time estimate:** Unknown (could be 2 hours or 2 days)

---

## Documentation References

- **Step 04 Q/A Report:** `docs/04_discussion.md`
- **Developer Implementation Log:** `docs/05_discussion.md`
- **Q/A Validation Instructions:** `docs/05_q_a.md`
- **Test Failures:** `services/integration-tests/build/reports/tests/test/index.html`

---

## Request for Decision

**Please provide guidance on:**
1. Which validation architecture to pursue
2. Whether to debug current implementation or pivot to alternative
3. Whether cross-service data access is acceptable pattern
4. Timeline expectations for Step 05 completion

---

**Status:** üî¥ BLOCKED - Awaiting Senior Engineer architectural decision
**Developer Available For:** Code implementation, additional debugging, pair programming session
**Estimated Time to Complete:** 2-6 hours depending on chosen approach
