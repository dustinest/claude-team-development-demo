# Step 07: Senior Engineer Instructions - Trading Service Improvements

**Date:** 2026-01-14
**From:** Product Owner
**To:** Senior Engineer
**Priority:** HIGH - Core Business Feature Validation

---

## Product Owner Context

### Business Requirement

We have a **fractional stock trading platform** where trading is the core business feature. Step 06 successfully consolidated user services, but revealed that trading operations remain unvalidated.

**Current Integration Test Status:**
- **Passing:** 17/45 tests (37.8%)
- **Target:** 40-43 tests (89-96%)
- **Gap:** 23-26 tests

**Critical Finding from Q/A (Step 06):**
- 21+ trading operation tests failing due to Content-Type header issue
- Portfolio tests failing (dependent on trading)
- Root cause identified: Trading service not returning `Content-Type: application/json` header

### Business Impact

**Cannot ship a trading platform without validated trading operations.** The missing test coverage represents unacceptable business risk for our core feature.

---

## Technical Context from Q/A

### Step 06 Q/A Validation Report (Excerpt)

**Integration Test Breakdown:**
- ✅ Schema Isolation: 4/4 PASS (100%)
- ✅ Wallet Operations: 7/7 PASS (100%)
- ✅ Currency Exchange: 3/3 PASS (100%)
- ✅ User Validation: 2/2 PASS (100%)
- ❌ Trading Operations: 21+ FAIL
- ❌ Portfolio Tracking: Multiple FAIL (depends on trading)

**Test Failure Analysis:**
```
Error: Cannot parse content to interface java.util.Map because no content-type was present
```

**Q/A Findings:**
- Root Cause: Trading service responses missing `Content-Type: application/json` header
- Status: PRE-EXISTING ISSUE (unrelated to Step 06 refactoring)
- Impact: All trading/portfolio tests fail at REST-Assured parser level

### Integration Test Infrastructure

**Test Framework:**
- Spock/Groovy integration tests
- Located in: `services/integration-tests/`
- REST-Assured for HTTP testing
- Tests run against live Docker Compose environment

**Trading Service Endpoints (from Step 05):**
```
POST /api/v1/trades/buy     - Execute buy order
POST /api/v1/trades/sell    - Execute sell order
GET /api/v1/trades/{userId} - Get user's trades
GET /api/v1/trades/{tradeId} - Get specific trade
```

---

## Step 07 Objectives

### Primary Goal
Fix trading service Content-Type headers to unlock 21+ integration tests and reach 89%+ test coverage target.

### Success Criteria
1. ✅ All trading service endpoints return proper `Content-Type: application/json` header
2. ✅ Integration tests: 40+ tests passing (89%+)
3. ✅ Trading operations validated through automated tests
4. ✅ Portfolio tracking tests passing (dependent feature)
5. ✅ No regressions in existing functionality

### Secondary Goals
1. Improve integration test data isolation (Q/A recommendation)
2. Document trading service response patterns
3. Verify end-to-end trading flow through tests

---

## Senior Engineer Tasks

### 1. Root Cause Analysis

**Investigate:**
- Why are trading service responses missing Content-Type headers?
- Are other services affected? (Check portfolio-service, transaction-history-service)
- Is this a Quarkus configuration issue, JAX-RS annotation issue, or code implementation issue?

**Review:**
- `services/trading-service/src/main/java/.../resource/TradingResource.java`
- Response handling patterns in other working services (user-service, wallet-service)
- Quarkus REST configuration in `application.properties`

### 2. Architectural Recommendations

**Provide guidance on:**
- Proper JAX-RS annotations for JSON responses (@Produces annotation usage)
- Quarkus REST response handling best practices
- Should we use a global response filter for Content-Type?
- Should we audit all services for this issue proactively?

**Consider:**
- Consistency across all 10 microservices
- Future-proofing against similar issues
- Minimal code changes vs comprehensive fix

### 3. Integration Test Improvements

**Review integration test patterns:**
- How can we improve test data isolation? (Q/A noted conflicts between manual tests and automated tests)
- Should tests use unique identifiers (UUIDs, timestamps)?
- Should we implement database cleanup/reset between test runs?

**Recommendations needed for:**
- Test data generation strategy
- Test isolation best practices
- Pre-test and post-test cleanup hooks

### 4. Create Developer Instructions

**Document in `docs/07_dev.md`:**
- Specific code changes required for trading service
- JAX-RS annotation patterns to follow
- Testing instructions (how to verify locally)
- Expected integration test results after fix

**Include:**
- File paths to modify
- Code examples/patterns from working services
- Verification steps before handoff to Q/A

---

## Technical Constraints

### Must Preserve
- ✅ All existing functionality (user, wallet, currency exchange)
- ✅ Schema isolation architecture (Step 03)
- ✅ Event-driven patterns (Kafka)
- ✅ API contracts (OpenAPI specs)

### Integration Test Environment
- Tests run via: `./gradlew :services:integration-tests:test`
- Environment: Docker Compose with 14 containers
- Database: PostgreSQL with schema isolation
- Test execution time: ~30-60 seconds

### Known Working Patterns

**From user-service (working correctly):**
```java
@Path("/api/v1/users")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class UserResource {
    // Endpoints properly return Content-Type header
}
```

---

## Dependencies & Risks

### Dependencies
- Trading service code (created in Step 05)
- Integration test suite (created in Step 04)
- Docker Compose environment (14 containers)

### Risks
- **Low:** This is a configuration/annotation fix, minimal code impact
- **Medium:** Other services may have same issue
- **Mitigation:** Test all service endpoints as part of fix verification

### Impact on Timeline
- Expected SE effort: 30-60 minutes (analysis + documentation)
- Expected DEV effort: 1-2 hours (implementation + verification)
- Expected Q/A effort: 30-45 minutes (regression testing)
- **Total Step 07 estimate:** 2-3 hours

---

## Reference Documentation

### From Step 05 (Developer Implementation)
- `docs/05_dev.md` - Trading service implementation details
- Trading endpoints were created but not fully validated

### From Step 06 (Q/A Testing)
- `docs/06_discussion.md` - Q/A validation report with Content-Type findings
- `TEST_REPORT.md` - Complete test failure analysis

### Integration Test Locations
```
services/integration-tests/src/test/groovy/
├── com/trading/platform/integration/
│   ├── TradingOperationsSpec.groovy        # Trading tests (failing)
│   ├── PortfolioTrackingSpec.groovy        # Portfolio tests (failing)
│   ├── UserValidationSpec.groovy           # User tests (passing ✅)
│   ├── WalletOperationsSpec.groovy         # Wallet tests (passing ✅)
│   └── CurrencyExchangeSpec.groovy         # Exchange tests (passing ✅)
```

---

## Questions for Senior Engineer

Please address in your analysis:

1. **Scope:** Should we fix only trading-service or audit all services proactively?
2. **Pattern:** What's the recommended JAX-RS annotation pattern for Quarkus 3.6.4?
3. **Testing:** Should we add integration tests for Content-Type headers specifically?
4. **API Gateway:** Does API Gateway need updates to properly forward Content-Type headers?

---

## Expected Deliverables

### From Senior Engineer (This Phase)

1. **Root cause analysis**
   - Why Content-Type headers are missing
   - Which services are affected
   - Recommended fix approach

2. **Architectural guidance**
   - JAX-RS best practices for Quarkus
   - Global vs per-endpoint fix strategy
   - Service audit recommendations

3. **`docs/07_dev.md` creation**
   - Detailed implementation instructions for Developer
   - Code examples and patterns
   - Verification steps
   - Expected test results

4. **Update `docs/07_discussion.md`**
   - Document technical decisions
   - Rationale for chosen approach
   - Trade-offs considered

---

## Success Metrics

**Step 07 will be considered successful when:**

1. ✅ Integration tests: 40+ passing (89%+ coverage)
2. ✅ Trading operations validated through automated tests
3. ✅ Content-Type headers present on all applicable endpoints
4. ✅ No regressions in existing functionality
5. ✅ Q/A approval with comprehensive test report

---

## Next Steps After SE Completion

1. **Developer** reads `docs/07_dev.md` and implements fixes
2. **Developer** runs integration tests locally to verify
3. **Developer** creates `docs/07_q_a.md` with test instructions
4. **Q/A** runs comprehensive regression testing
5. **Q/A** validates 40+ test target achieved
6. **Q/A** approves Step 07 or loops back if issues found

---

## Product Owner Availability

I am available to answer business questions if needed:
- Clarify business requirements
- Prioritize trade-offs
- Approve scope changes

However, for technical decisions (annotation patterns, configuration strategies), Senior Engineer has full autonomy.

---

**[As Senior Engineer]** Please begin your analysis and create the developer implementation guide.

---

**Document created:** 2026-01-14
**Status:** Ready for Senior Engineer review
**Priority:** HIGH - Core business feature validation
**Estimated completion:** 2-3 hours total for Step 07
