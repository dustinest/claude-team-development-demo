# 03_se.md - Senior Engineer Instructions for Step 03

**Role:** Senior Engineer
**Phase:** Step 03 - Architectural Review and Decision
**Date:** 2026-01-13
**From:** Q/A Specialist
**Priority:** CRITICAL - System Non-Functional

---

## Situation Overview

**Current Status:** System crashed during Step 02 regression testing
**Root Cause:** Architectural issue with database schema isolation
**Impact:** 5 of 15 services non-functional
**Required:** Senior Engineer architectural decision

---

## Background

### Step 01 (Initial Implementation)
- All 10 microservices implemented
- Q/A discovered 2 critical bugs

### Step 02 (Developer Bug Fixes)
- Developer fixed BUG #2 (Kafka event flow) ✅
- Developer's fix for BUG #1 (Flyway) was incomplete ❌
- New failure mode introduced: Services crash due to shared schema issue

### Current Problem
All microservices share the same PostgreSQL "public" schema:
- fee-service starts first and creates tables
- Other services see "non-empty schema" and Flyway refuses to run migrations
- 5 services crash on startup with Flyway exception

**This is an ARCHITECTURAL DESIGN issue requiring your expertise.**

---

## Your Responsibilities

### 1. Architectural Decision

**Primary Task:** Decide how microservices should interact with PostgreSQL

You must choose between:

**A. Separate Schemas per Service** (Recommended)
- Each service gets its own PostgreSQL schema
- True isolation between services
- Clean microservice architecture

**B. Corrected Baseline Configuration**
- Keep shared schema with fixed Flyway configuration
- Simpler but violates isolation principles

**C. Other Solution**
- Your alternative architectural approach

### 2. Spock Test Strategy

You previously instructed Developer to implement Spock tests (docs/01_se.md) but this was deferred due to bugs.

**Decision Required:**
- Should Spock tests be implemented in Step 03?
- Or continue deferring until system is stable?

### 3. Architecture Documentation

Update system architecture to reflect your decisions:
- Database schema strategy
- Service isolation principles
- Migration and deployment strategy

---

## The Problem in Detail

### What's Happening

```
PostgreSQL Database: "trading"
│
└── Schema: "public" (SHARED - ALL SERVICES USE THIS)
    │
    ├── Startup Sequence (race condition):
    │
    │   1. fee-service starts
    │      ✅ Sees empty "public" schema
    │      ✅ Runs Flyway V1 migration
    │      ✅ Creates: fee_rules, flyway_schema_history_fee
    │      ✅ Service running
    │
    │   2. user-service starts
    │      ❌ Sees "public" schema with fee_rules
    │      ❌ Flyway detects "non-empty schema"
    │      ❌ No baseline configured (removed in Step 02)
    │      ❌ Flyway throws exception
    │      ❌ Service CRASHES
    │
    │   3. wallet-service, trading-service, portfolio-service, transaction-history-service
    │      ❌ All crash with same error
```

### The Error
```
org.flywaydb.core.api.FlywayException:
Found non-empty schema(s) "public" but no schema history table.
Use baseline() or set baselineOnMigrate to true to initialize the schema history table.
```

### Why This Happened

**Step 01 Bug:** Developer used `baseline-on-migrate=true`
- Problem: On *empty* schema, Flyway baselines to V1 and skips V1 migrations
- Result: No application tables created

**Step 02 Fix:** Developer removed `baseline-on-migrate=true`
- Solved: Empty schema problem
- Created: Non-empty schema problem (services share schema)

**Root Cause:** No schema isolation between services

---

## Recommended Solution: Separate Schemas (Option A)

### Architecture

```
PostgreSQL Database: "trading"
│
├── Schema: "user_service" (user-service only)
│   ├── users
│   └── flyway_schema_history
│
├── Schema: "wallet_service" (wallet-service only)
│   ├── wallet_balances
│   └── flyway_schema_history
│
├── Schema: "trading_service" (trading-service only)
│   ├── trades
│   └── flyway_schema_history
│
├── Schema: "portfolio_service" (portfolio-service only)
│   ├── holdings
│   └── flyway_schema_history
│
├── Schema: "transaction_history_service" (transaction-history-service only)
│   ├── transactions
│   └── flyway_schema_history
│
└── Schema: "fee_service" (fee-service only)
    ├── fee_rules
    └── flyway_schema_history
```

### Benefits

1. **True Microservice Isolation:** Each service owns its data
2. **Flyway Works Naturally:** Each service sees empty schema on first run
3. **Clear Ownership:** Schema name = service name
4. **Prevents Coupling:** Services can't accidentally query each other's tables
5. **Production Ready:** Clean architecture that scales

### Implementation

**For each of the 6 services with databases:**

#### File: `services/{service-name}/src/main/resources/application.properties`

**Change FROM:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading
quarkus.flyway.migrate-at-start=true
quarkus.flyway.locations=db/migration
quarkus.flyway.table=flyway_schema_history_{service}
# baseline-on-migrate was removed (causing crash)
```

**Change TO:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema={service_schema_name}
quarkus.flyway.schemas={service_schema_name}
quarkus.flyway.migrate-at-start=true
quarkus.flyway.locations=db/migration
quarkus.flyway.table=flyway_schema_history
```

#### Specific Values per Service:

**user-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=user_service
quarkus.flyway.schemas=user_service
```

**wallet-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=wallet_service
quarkus.flyway.schemas=wallet_service
```

**trading-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=trading_service
quarkus.flyway.schemas=trading_service
```

**portfolio-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=portfolio_service
quarkus.flyway.schemas=portfolio_service
```

**transaction-history-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=transaction_history_service
quarkus.flyway.schemas=transaction_history_service
```

**fee-service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading?currentSchema=fee_service
quarkus.flyway.schemas=fee_service
```

### Migration Path

**For development (docker-compose):**
1. Remove `baseline-on-migrate` (keep Developer's Step 02 changes)
2. Add `currentSchema` parameter to JDBC URL
3. Add `quarkus.flyway.schemas` property
4. Simplify flyway table name to just `flyway_schema_history`
5. Run `docker-compose down -v` (fresh database)
6. Run `docker-compose up --build`

PostgreSQL will automatically create schemas when services first connect.

---

## Alternative Solution: Corrected Baseline (Option B)

**If you prefer to keep shared schema (not recommended):**

### Configuration

**For each service:**
```properties
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/trading
quarkus.flyway.migrate-at-start=true
quarkus.flyway.locations=db/migration
quarkus.flyway.table=flyway_schema_history_{service}
quarkus.flyway.baseline-on-migrate=true
quarkus.flyway.baseline-version=0  # KEY: Set to 0, not 1
```

### How It Works

- `baseline-version=0` means "baseline is V0"
- V1 migrations will run after baseline
- Works for both empty and non-empty schemas

### Why Not Recommended

- ❌ All services see all tables (no isolation)
- ❌ Potential for accidental coupling
- ❌ Violates microservice principles
- ❌ Harder to reason about data ownership

---

## Spock Test Considerations

### Original Instruction (Step 01)
In `docs/01_se.md`, you instructed Developer to add Spock tests to each service.

### Current Status
- No tests implemented yet (deferred due to bugs)
- System needs to be functional before meaningful tests can be written

### Your Decision Required

**Option 1:** Implement Spock tests in Step 03
- ✅ Test-driven approach
- ❌ Delays bug fix validation

**Option 2:** Defer Spock tests to Step 04
- ✅ Fix architecture first
- ✅ Test working system
- ✅ Recommended

**Option 3:** Different test strategy
- Your alternative approach

---

## Instructions for Developer (After Your Decision)

**Create this section in your response:**

### For Developer: Implementation Tasks

1. **Database Schema Configuration**
   - [List specific file changes]
   - [Provide exact configuration]
   - [Include verification steps]

2. **Testing Instructions**
   - [How to test locally]
   - [Expected results]
   - [Definition of done]

3. **Spock Tests (if applicable)**
   - [Guidance on test implementation]
   - [Or confirmation of deferral]

---

## Required Deliverables

Please provide in your response:

### 1. Architectural Decision
**Which option:** A (Separate Schemas), B (Corrected Baseline), or C (Your alternative)
**Rationale:** Why this approach is best for this system

### 2. Implementation Plan
- Specific configuration changes required
- Files to modify
- Step-by-step instructions for Developer

### 3. Spock Test Decision
- Implement now or defer?
- If implement: guidance and examples
- If defer: rationale

### 4. Architecture Updates
- Updated system architecture description
- Database schema strategy
- Service isolation principles
- Any production deployment considerations

### 5. Definition of Done for Step 03
- What must be verified before Q/A testing?
- Success criteria
- Testing checklist

---

## Context Documents

**For your reference:**
- `TEST_REPORT.md` - Q/A findings from Step 02
- `docs/03_discussion.md` - Detailed problem analysis
- `docs/01_se.md` - Your original Step 01 instructions
- `docs/02_discussion.md` - Developer's Step 02 work
- `docs/02_dev.md` - Q/A's Step 02 instructions to Developer

---

## Questions to Consider

1. **Schema Isolation:** Should microservices share database schemas?
2. **Migration Strategy:** How should Flyway be configured for shared vs. isolated schemas?
3. **Service Boundaries:** How do we enforce data ownership?
4. **Testing Strategy:** When should comprehensive tests be added?
5. **Production Readiness:** How does this work in Kubernetes/production?

---

## Timeline

**Urgency:** HIGH - System is currently non-functional
**Blocking:** Q/A testing cannot proceed until architecture is fixed
**Next Phase:** Developer implementation → Q/A validation

---

**Your response should be comprehensive architectural guidance that resolves this issue permanently.**

Good luck!
