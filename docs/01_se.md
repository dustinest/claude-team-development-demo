# 01_se.md - Instructions for Senior Engineer

## Overview

This document provides the Senior Engineer with all the context and requirements gathered from the Product Owner's Q/A session with the Operator. Your task is to design the technical architecture, select appropriate technologies, and create detailed implementation instructions for the Developer.

## Project Vision

We are building a **Fractional Stock Trading Platform** designed for young investors. The platform allows users to buy and sell fractions of stocks (down to 0.01 units, 2 decimal places) in multiple currencies (USD, EUR, GBP). The platform emphasizes transparency (showing all fees) and customer-friendly rounding.

## Technical Constraints

### Mandatory Technologies
- **Java 21** - Production code language
- **Spock/Groovy** - Testing framework
- **Gradle with Kotlin DSL** - Build tool
- **Quarkus** - Application framework (optimized for lambdas/serverless)
- **Docker** - All services must be runnable in Docker containers
- **Microservices Architecture** - Each business capability is a separate service
- **Kafka** (suggested) - Internal service communication via messaging
- **REST** - External integrations (currency/securities services)

### Database Requirements
- You must select appropriate database technology/technologies
- Must be runnable in Docker
- Must be AWS-native compatible (future cloud deployment)
- Consider: transactional requirements, scalability, data consistency needs

### Deployment Target
- Initial: Docker Compose (local development, Q/A)
- Future: AWS (design with cloud-native patterns)

## Functional Requirements

### 1. User Management
- **User Signup Service (Mock)**: Broadcasts new user registrations
  - Generates UUID for user ID
  - Captures: email, username, phone number (all unique)
  - No validation beyond uniqueness
  - Broadcasts via messaging to other services
- **User Service**: Stores and manages user data
  - User ID (UUID)
  - Credentials (email, username, phone number)
  - NO authentication/authorization in scope

### 2. Wallet Service
- Multi-currency wallet per user
- Separate balance per currency (USD, EUR, GBP)
- Operations:
  - Deposit funds (currency, amount)
  - Withdraw funds (currency, amount)
  - Currency exchange (from currency, to currency, amount)
  - Query balance (single currency or all currencies)
- All operations create transaction records

### 3. Trading Service
- Buy/sell securities in fractions (0.01 precision, 2 decimal places)
- Two order types:
  - **By money amount**: User specifies money, system calculates security quantity
  - **By security quantity**: User specifies quantity, system calculates cost
- Immediate execution (market orders only)
- No limit orders, no pending orders
- No minimum trade restrictions
- Operations:
  - Execute buy order
  - Execute sell order
  - Validate sufficient funds/holdings
- Integrates with:
  - Wallet Service (deduct/add funds)
  - Portfolio Service (update holdings)
  - Fee Service (calculate fees)
  - Securities Pricing Service (get current price)
  - Currency Exchange Service (if needed)
  - Transaction History Service (record transaction)

### 4. Portfolio Service
- Track user holdings per security
- Calculate:
  - Current value in any supported currency (on-the-fly conversion)
  - Profit/loss by date range (day, week, month, year, YTD)
  - Average purchase price per security
- Operations:
  - Update holdings (buy/sell)
  - Get portfolio (all holdings)
  - Get portfolio value in chosen currency
  - Get profit/loss for date range

### 5. Transaction History Service
- Record ALL financial operations:
  - Deposits
  - Withdrawals
  - Currency exchanges
  - Security buys
  - Security sells
  - ALL fees applied
- Operations:
  - Record transaction
  - Query transaction history (user, date range, type filters)

### 6. Fee Service
- Determines fees for operations
- Fee structure per security:
  - Fixed fee (can be 0)
  - Percentage fee (can be 0)
- Fee structure for currency exchange:
  - Fixed fee (can be 0)
  - Percentage fee (can be 0)
- Operations:
  - Get trading fee (security, operation type)
  - Get currency exchange fee (from currency, to currency)
  - Calculate total fee (base amount, fee structure)

### 7. Securities Pricing Service (Mock)
- Provides security prices
- Mock data: 10 popular stocks, 5 stock indexes, 5 bond indexes
- Realistic but randomized prices with fluctuations
- Operations:
  - Get all securities with prices
  - Get single security price
  - Prices returned in USD (base currency)

### 8. Currency Exchange Service (Mock)
- Provides exchange rates between USD, EUR, GBP
- Realistic rates with periodic changes
- Operations:
  - Get exchange rate (from currency, to currency)
  - Get all exchange rates

### 9. API Gateway / Aggregation Layer (Optional)
- Consider if a gateway or BFF (Backend for Frontend) is needed
- REST API endpoints for frontend consumption

## Architecture Decisions Required

### 1. Microservices Communication
- **Synchronous (REST)**: Which services need REST APIs?
- **Asynchronous (Kafka)**: Which services communicate via events?
- **Event-driven patterns**: Which operations should publish domain events?
- **Saga pattern**: For distributed transactions (e.g., trade execution)?

### 2. Data Management
- **Database per service**: Which database for each service?
  - Transactional services (wallet, trading): PostgreSQL? MySQL?
  - High-read services (portfolio, transaction history): PostgreSQL? MongoDB?
  - Caching layer needed? (Redis?)
- **Data consistency**: Eventual consistency patterns? Transactional guarantees?
- **Schema design**: Key entities and relationships per service

### 3. API Design
- REST API contracts for external consumption
- API documentation approach (OpenAPI/Swagger?)
- Error handling patterns
- Pagination, filtering, sorting standards

### 4. Mock Service Implementation
- How realistic should price fluctuations be?
- Should mocks support time-based scenarios (e.g., market hours)?
- Data initialization approach (static seed data?)

### 5. Fractional Calculation Strategy
- Precision handling (BigDecimal usage)
- Rounding rules (always favor customer)
- Fee calculation order (before/after rounding?)

### 6. UI Decision
**IMPORTANT**: Decide whether to include a simple React frontend in this iteration:
- **If YES**: Low-hanging fruit, provides immediate value
  - Simple React SPA
  - Basic UI for key user flows (signup, deposit, trade, portfolio)
  - API integration layer
- **If NO**: Focus on backend APIs
  - Comprehensive API documentation for future frontend team
  - Postman collections or similar for testing

### 7. Docker & Local Development
- Docker Compose structure
- Service orchestration
- Local development workflow
- Database initialization scripts

### 8. Observability & Operations
- Logging strategy (structured logging?)
- Health check endpoints
- Metrics/monitoring approach (Prometheus?)
- Distributed tracing? (Jaeger?)

## Success Criteria

The architecture should enable:
1. Many users can register with credentials
2. Users can deposit/withdraw funds in multiple currencies
3. Users can exchange currencies in their wallet
4. Users can request list of securities in chosen currency with prices
5. Users can request single security price in chosen currency
6. Users can buy/sell security fractions (by money or quantity)
7. Users can view portfolio in chosen currency with profit/loss
8. Users can view complete transaction history with fees
9. All services are scalable and runnable in Docker
10. APIs are documented for future frontend integration

## Your Deliverables

### 1. System Architecture
- Overall architecture diagram (microservices, data flow)
- Service interaction patterns (sync/async)
- Data architecture (databases, persistence)

### 2. Technology Selections
- Database choices per service with rationale
- Kafka configuration approach
- Additional libraries/frameworks needed
- API documentation tooling

### 3. Service Design
- Each service's responsibilities
- API contracts (REST endpoints)
- Event schemas (Kafka topics, message formats)
- Data models per service

### 4. Implementation Strategy
- Build order (which services first?)
- Mock service implementation approach
- Testing strategy
- Docker Compose setup

### 5. UI Decision & Plan
- Decision: Build React UI now or defer?
- If yes: High-level UI structure and pages
- If no: API documentation requirements

### 6. Developer Instructions
Create **`01_dev.md`** with:
- Detailed implementation instructions
- Service-by-service implementation plan
- Code structure guidelines
- API contracts to implement
- Testing requirements
- Docker configuration needs

## Notes from Product Owner

- **Fractional precision**: 2 decimal places maximum (0.01 minimum)
- **Customer-friendly rounding**: Always round in customer's favor; fees cover this
- **Transparency**: All fees must be clearly shown to users
- **No authentication yet**: User ID passed as parameter
- **Scalability**: Design for horizontal scaling (lambda-friendly with Quarkus)
- **AWS-ready**: Keep future AWS deployment in mind

## Questions for Operator

If you need clarification on technical preferences or constraints, ask the Operator:
- Database technology preferences
- Kafka vs alternatives
- UI framework beyond React
- Specific AWS services to target
- Performance requirements (requests/sec, latency)

## Next Steps

1. Review `01_discussion.md` for complete context
2. Make architectural decisions
3. Document your design in `01_discussion.md` (append your analysis)
4. Create `01_dev.md` with implementation instructions for Developer
5. Update `01_summary.md` with architectural decisions

---

**[As Product Owner]** I'm confident this provides sufficient context for you to design a robust, scalable architecture. Please ask any clarifying questions before proceeding with your technical design.
