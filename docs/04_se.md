# 04_se.md - Senior Engineer Test Strategy for Step 04

**Role:** Senior Engineer
**Phase:** Step 04 - Comprehensive Integration Testing
**Date:** 2026-01-13
**Priority:** HIGH - Quality Assurance for Production Readiness

---

## Overview

Step 03 delivered a fully functional microservices trading platform with proper schema isolation architecture. All manual Q/A tests passed (10/10). However, the system lacks automated integration tests to ensure reliability and catch regressions during future development.

**Step 04 Objective:** Implement comprehensive Spock integration tests covering critical user flows, cross-service interactions, and edge cases.

---

## Testing Strategy

### Philosophy

**Test the System as Users Experience It**
- Focus on end-to-end flows, not isolated units
- Test through public APIs (REST endpoints)
- Verify database state changes
- Validate Kafka event flows
- Test error handling and edge cases

**Production-Ready Quality**
- 80% coverage target for core services (User, Wallet, Trading, Portfolio)
- Integration tests that catch real issues
- Fast enough to run in CI/CD pipeline
- Maintainable and readable test specifications

---

## Test Architecture

### Technology Stack

**Spock Framework**
- Groovy-based BDD testing framework
- Given-When-Then syntax for clarity
- Powerful mocking and stubbing
- Excellent for integration testing

**TestContainers**
- Docker-based test infrastructure
- Real PostgreSQL, Kafka, Redis instances
- Isolated test environments
- No mock database behavior

**REST-assured**
- Java library for API testing
- Fluent API for HTTP requests
- JSON path validation
- Integration with Spock

### Test Project Structure

```
services/
└── integration-tests/          # New Gradle subproject
    ├── build.gradle
    └── src/
        └── test/
            └── groovy/
                └── com/trading/integration/
                    ├── BaseIntegrationSpec.groovy
                    ├── user/
                    │   └── UserRegistrationSpec.groovy
                    ├── wallet/
                    │   ├── WalletDepositSpec.groovy
                    │   ├── WalletWithdrawSpec.groovy
                    │   └── CurrencyExchangeSpec.groovy
                    ├── trading/
                    │   ├── BuyOrderSpec.groovy
                    │   ├── SellOrderSpec.groovy
                    │   └── FractionalSharesSpec.groovy
                    ├── portfolio/
                    │   └── PortfolioTrackingSpec.groovy
                    ├── flows/
                    │   └── CompleteUserJourneySpec.groovy
                    └── infrastructure/
                        ├── SchemaIsolationSpec.groovy
                        └── KafkaEventFlowSpec.groovy
```

---

## Priority Test Suites

### Suite 1: User Management (CRITICAL)
**Coverage:** User Signup Service + User Service + Kafka

**Test Cases:**
1. **UserRegistrationSpec**
   - Successful user registration with valid data
   - User persisted to database in correct schema
   - Kafka event published to user-events topic
   - User service consumes event and creates user record
   - Duplicate email validation
   - Invalid email format handling
   - Missing required fields validation

**Why Critical:** Foundation for all other operations. If user registration fails, nothing else works.

---

### Suite 2: Wallet Operations (CRITICAL)
**Coverage:** Wallet Service + Fee Service + Currency Exchange Service

**Test Cases:**

2. **WalletDepositSpec**
   - Deposit USD to new wallet (creates wallet_balance record)
   - Deposit to existing wallet (updates balance)
   - Multiple currency deposits (USD, EUR, GBP)
   - Negative amount rejection
   - Zero amount rejection
   - Balance calculation accuracy
   - Kafka event publishing

3. **WalletWithdrawSpec**
   - Withdraw from wallet with sufficient balance
   - Insufficient balance error handling
   - Withdraw entire balance (balance = 0)
   - Negative amount rejection
   - Withdraw from non-existent wallet

4. **CurrencyExchangeSpec**
   - Exchange USD to EUR
   - Exchange EUR to GBP
   - Exchange with insufficient source balance
   - Fee calculation verification
   - Exchange rate application
   - Balance updates in both currencies

**Why Critical:** Money handling must be 100% correct. No room for errors in financial operations.

---

### Suite 3: Trading Operations (CRITICAL)
**Coverage:** Trading Service + Securities Pricing + Portfolio + Transaction History

**Test Cases:**

5. **BuyOrderSpec**
   - Buy by amount (fractional shares calculated)
   - Buy by quantity (exact shares)
   - Insufficient wallet balance handling
   - Fee calculation and deduction
   - Portfolio holding creation
   - Transaction history recording
   - Kafka event publishing
   - Average price calculation (first purchase)
   - Average price update (subsequent purchases)

6. **SellOrderSpec**
   - Sell all holdings
   - Sell partial holdings
   - Sell more than owned (error handling)
   - Fee calculation on sale
   - Portfolio holding update
   - Wallet balance increase
   - Transaction history recording

7. **FractionalSharesSpec**
   - Buy 0.01 shares (minimum precision)
   - Buy 1.5 shares (fractional amount)
   - Sell 0.5 shares
   - Precision handling (no rounding errors)
   - Customer-favorable rounding verification

**Why Critical:** Core business logic. Trading accuracy determines platform trustworthiness.

---

### Suite 4: Portfolio Tracking (HIGH)
**Coverage:** Portfolio Service + Trading Service + Kafka

**Test Cases:**

8. **PortfolioTrackingSpec**
   - Empty portfolio for new user
   - Portfolio after first purchase
   - Portfolio after multiple purchases (average price calculation)
   - Portfolio after partial sale
   - Portfolio after complete sale (holding removed)
   - Multi-security portfolio
   - Portfolio value calculation

**Why High:** Users need accurate portfolio data. Incorrect holdings = loss of trust.

---

### Suite 5: Complete User Journey (HIGH)
**Coverage:** All services end-to-end

**Test Cases:**

9. **CompleteUserJourneySpec**
   - Register user
   - Deposit USD to wallet
   - Buy AAPL shares by amount
   - View portfolio (verify holding)
   - Sell partial AAPL shares
   - View transaction history (all steps recorded)
   - Verify wallet balance after fees
   - Verify portfolio reflects remaining shares

**Why High:** Integration test that validates entire system works together. Simulates real user behavior.

---

### Suite 6: Infrastructure & Architecture (MEDIUM)
**Coverage:** Database schemas, Kafka, service isolation

**Test Cases:**

10. **SchemaIsolationSpec**
    - Each service writes to its own schema
    - Services cannot access other services' schemas
    - Concurrent service operations don't interfere
    - Flyway migrations independent per service

11. **KafkaEventFlowSpec**
    - Events published successfully
    - Events consumed by correct services
    - Event ordering preserved
    - Consumer idempotency (duplicate event handling)
    - Dead letter queue handling (if implemented)

**Why Medium:** Architecture is proven in Step 03. These tests verify it stays correct during changes.

---

## Test Coverage Targets

| Service | Target Coverage | Priority |
|---------|----------------|----------|
| User Service | 80% | CRITICAL |
| Wallet Service | 80% | CRITICAL |
| Trading Service | 80% | CRITICAL |
| Portfolio Service | 80% | HIGH |
| Transaction History | 70% | HIGH |
| User Signup Service | 75% | HIGH |
| Fee Service | 60% | MEDIUM |
| Currency Exchange | 60% | MEDIUM |
| Securities Pricing | 50% | MEDIUM |
| API Gateway | 50% | MEDIUM |

**Overall Target:** 75% average coverage across all services

---

## Technical Implementation Guidance

### Base Test Specification

All integration tests should extend `BaseIntegrationSpec`:

```groovy
abstract class BaseIntegrationSpec extends Specification {

    @Shared
    static PostgreSQLContainer postgres

    @Shared
    static KafkaContainer kafka

    @Shared
    static GenericContainer redis

    def setupSpec() {
        // Start TestContainers
        // Configure services to use test infrastructure
        // Wait for services to be healthy
    }

    def cleanupSpec() {
        // Stop containers
    }

    def setup() {
        // Clean database schemas between tests
        // Clear Kafka topics
        // Reset Redis cache
    }

    // Helper methods for common operations
    String createTestUser(String email) { ... }
    void depositToWallet(String userId, String currency, BigDecimal amount) { ... }
    Map buyShares(String userId, String symbol, BigDecimal amount) { ... }
}
```

### Test Writing Guidelines

**1. Use Clear Given-When-Then Structure**
```groovy
def "user registration creates user in database and publishes Kafka event"() {
    given: "a new user registration request"
    def email = "test${UUID.randomUUID()}@example.com"
    def request = [
        email: email,
        username: "testuser",
        phoneNumber: "+1234567890"
    ]

    when: "user signs up via API"
    def response = given()
        .contentType(ContentType.JSON)
        .body(request)
        .post("http://localhost:8080/api/v1/signup")
        .then()
        .statusCode(201)
        .extract().response()

    and: "we wait for Kafka event processing"
    Thread.sleep(2000)

    then: "user is created with valid UUID"
    response.path("userId") != null
    UUID.fromString(response.path("userId"))

    and: "user exists in user_service schema"
    def userId = response.path("userId")
    def dbUser = queryDatabase("SELECT * FROM user_service.users WHERE id = '${userId}'")
    dbUser.size() == 1
    dbUser[0].email == email

    and: "event was published to Kafka"
    def events = consumeKafkaEvents("user-events", 1)
    events.size() == 1
    events[0].userId == userId
}
```

**2. Test Error Paths, Not Just Happy Paths**
```groovy
def "deposit with negative amount returns 400 error"() {
    given: "a user with a wallet"
    def userId = createTestUser("test@example.com")

    when: "attempting to deposit negative amount"
    def response = given()
        .contentType(ContentType.JSON)
        .body([currency: "USD", amount: -100.00])
        .post("http://localhost:8086/api/v1/wallets/${userId}/deposit")
        .then()
        .extract().response()

    then: "request is rejected with 400 Bad Request"
    response.statusCode() == 400
    response.path("error") != null
}
```

**3. Verify Database State Changes**
```groovy
and: "wallet balance is updated in wallet_service schema"
def balance = queryDatabase(
    "SELECT balance FROM wallet_service.wallet_balances WHERE user_id = '${userId}' AND currency = 'USD'"
)
balance[0].balance == 1000.00
```

**4. Verify Kafka Events**
```groovy
and: "wallet event is published to Kafka"
def events = consumeKafkaEvents("wallet-events", 1, 5000)
events.size() == 1
events[0].userId == userId
events[0].eventType == "DEPOSIT"
events[0].amount == 1000.00
```

**5. Test Concurrent Operations**
```groovy
def "concurrent deposits to same wallet are handled correctly"() {
    given: "a user with a wallet"
    def userId = createTestUser("test@example.com")

    when: "10 concurrent deposits of $100 each"
    def futures = (1..10).collect {
        CompletableFuture.supplyAsync {
            depositToWallet(userId, "USD", 100.00)
        }
    }
    CompletableFuture.allOf(futures as CompletableFuture[]).join()

    then: "final balance is exactly $1000 (no lost updates)"
    def balance = getWalletBalance(userId, "USD")
    balance == 1000.00
}
```

---

## Test Data Management

### Strategy: Fresh Data Per Test

- Use `UUID.randomUUID()` for unique test data
- Clean database schemas in `setup()` method
- No shared test data between tests
- Each test is independent and can run in any order

### Example:
```groovy
def setup() {
    // Clean all service schemas
    executeSQL("TRUNCATE TABLE user_service.users CASCADE")
    executeSQL("TRUNCATE TABLE wallet_service.wallet_balances CASCADE")
    executeSQL("TRUNCATE TABLE trading_service.trades CASCADE")
    executeSQL("TRUNCATE TABLE portfolio_service.holdings CASCADE")
    executeSQL("TRUNCATE TABLE transaction_history_service.transactions CASCADE")

    // Reset Kafka offsets
    resetKafkaConsumerGroups()
}
```

---

## Performance Considerations

### Test Execution Speed

**Target:** Complete test suite runs in < 10 minutes

**Optimizations:**
1. **Parallel Execution:** Run independent test classes in parallel
2. **Shared Infrastructure:** Reuse TestContainers across tests in same class
3. **Minimal Wait Times:** Use polling with timeout instead of fixed sleeps
4. **Fast Database Cleanup:** TRUNCATE instead of DELETE

### Example Polling:
```groovy
// Instead of: Thread.sleep(5000)
// Use:
await().atMost(5, SECONDS).pollInterval(100, MILLISECONDS).until {
    getWalletBalance(userId, "USD") == expectedBalance
}
```

---

## Error Handling Scenarios

### Critical Error Paths to Test

1. **Insufficient Funds**
   - Withdraw more than balance
   - Buy shares without enough USD
   - Exchange without sufficient source currency

2. **Invalid Input**
   - Negative amounts
   - Zero amounts (where invalid)
   - Invalid currency codes
   - Invalid security symbols
   - Malformed email addresses

3. **Resource Not Found**
   - Operate on non-existent user
   - Operate on non-existent wallet
   - Sell shares not owned

4. **Concurrent Modification**
   - Double-spending prevention
   - Race condition handling
   - Optimistic locking verification

5. **External Service Failures**
   - Securities pricing service down
   - Fee service unavailable
   - Currency exchange service down

---

## Integration with CI/CD

### Gradle Configuration

```gradle
// integration-tests/build.gradle
test {
    useJUnitPlatform()

    // Parallel execution
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1

    // Test timeouts
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
    }

    // Test categories
    systemProperty "test.profile", System.getProperty("test.profile", "integration")
}

// Separate tasks for different test suites
task criticalTests(type: Test) {
    include '**/user/**', '**/wallet/**', '**/trading/**'
}

task fullIntegrationTests(type: Test) {
    include '**/*Spec.groovy'
}
```

### CI Pipeline Integration

```yaml
# .github/workflows/integration-tests.yml
name: Integration Tests

on: [push, pull_request]

jobs:
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-java@v2
        with:
          java-version: '21'
      - name: Run Critical Tests
        run: ./gradlew criticalTests
      - name: Run Full Integration Tests
        run: ./gradlew fullIntegrationTests
      - name: Publish Test Report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Integration Test Results
          path: '**/build/test-results/**/*.xml'
          reporter: java-junit
```

---

## Definition of Done - Step 04

### Senior Engineer Responsibilities (This Document) ✅
- ✅ Test strategy defined
- ✅ Test suites prioritized (11 test specifications)
- ✅ Architecture and patterns established
- ✅ Implementation guidance provided
- ✅ Developer instructions ready (see docs/04_dev.md)

### Developer Responsibilities
- [ ] Create integration-tests Gradle subproject
- [ ] Implement BaseIntegrationSpec with TestContainers
- [ ] Implement all 11 test specifications
- [ ] Achieve 75%+ average test coverage
- [ ] All tests passing (green)
- [ ] Document any issues discovered

### Q/A Responsibilities
- [ ] Execute full integration test suite
- [ ] Verify all tests pass
- [ ] Validate test coverage reports
- [ ] Confirm no regressions from Step 03
- [ ] Provide final sign-off

---

## Success Criteria

**Minimum Acceptable:**
- All CRITICAL tests implemented (Suites 1-3)
- All tests passing (100% pass rate)
- 75% average coverage across core services
- Tests run in < 10 minutes

**Target Achievement:**
- All 11 test specifications implemented
- 80%+ coverage for critical services
- < 5 minute test execution time
- Zero bugs discovered during testing

**Excellence:**
- Additional edge case coverage beyond specifications
- Performance tests included
- Test documentation with examples
- Reusable test utilities for future tests

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| TestContainers slow startup | HIGH | Reuse containers across tests, use parallel execution |
| Kafka timing issues | MEDIUM | Use await() polling instead of sleep(), increase timeouts if needed |
| Database cleanup overhead | MEDIUM | Use TRUNCATE CASCADE, create indexes on test columns |
| Test flakiness | HIGH | Ensure proper cleanup, avoid timing dependencies, use unique test data |
| Coverage too low | MEDIUM | Focus on critical paths first, add tests iteratively |

---

## Next Steps

1. **Developer:** Read docs/04_dev.md for detailed implementation instructions
2. **Developer:** Implement test infrastructure (BaseIntegrationSpec)
3. **Developer:** Implement CRITICAL test suites (1-3)
4. **Developer:** Implement HIGH priority test suites (4-5)
5. **Developer:** Implement MEDIUM priority tests if time permits
6. **Q/A:** Execute test suite and verify results
7. **Team:** Review coverage reports and decide if additional tests needed

---

**[As Senior Engineer]** This testing strategy provides production-grade quality assurance for the trading platform. The focus on integration tests (not mocks) ensures we catch real issues. The 11 test specifications cover critical user journeys and edge cases. Once implemented, this test suite will enable confident future development with fast feedback on regressions.

The architecture is solid from Step 03. Now we need automated tests to keep it that way.

Good luck with implementation!
