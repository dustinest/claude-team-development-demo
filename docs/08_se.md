# Step 08: Senior Engineer Instructions - Test Infrastructure Improvements

**Date:** 2026-01-14
**From:** Product Owner
**To:** Senior Engineer
**Priority:** HIGH
**Context:** Step 07 Q/A CONDITIONAL PASS - Test coverage below target

---

## Product Owner Directive

**Status:** Step 07 achieved its primary goal (Trading Service API refactoring), but test coverage remains below acceptable threshold for a trading platform.

**Current State:**
- Test Coverage: 24/45 (53.3%)
- Target: 40+ tests (89%)
- Gap: 16 tests
- Token Budget: 149,380 remaining (74.7%)

**Business Risk:**
This is a **fractional stock trading platform** where trading is the core business feature. We cannot ship with:
- 21 unvalidated test scenarios
- 0% Kafka event flow test coverage (0/6 tests)
- 33% complete journey test coverage (1/3 tests)

**Decision:** Proceed with Step 08 to improve test infrastructure and reach 89%+ test coverage.

---

## Senior Engineer Tasks

### 1. Review Q/A Analysis

Q/A has identified the root causes of the 21 failing tests:

**Root Cause #1: Test Timing Issues (15-20 tests)**
- Tests use fixed `Thread.sleep()` delays (1-5 seconds)
- Kafka events not processed within test wait times
- Database queries return empty results before events complete

**Root Cause #2: Test Data Isolation (2-3 tests)**
- Duplicate email registration test expects 409, gets 201
- Database cleanup incomplete between tests
- cleanDatabase() method may not be effective

**Root Cause #3: Wallet Balance Integration (1 test)**
- Buy order test shows wallet balance not reduced after trade
- Possible timing issue between trading-service → wallet-service

### 2. Architectural Decisions Required

**Decision #1: Test Timing Strategy**

Evaluate and recommend approach for handling asynchronous Kafka event testing:

**Option A: Awaitility Framework (RECOMMENDED by Q/A)**
```groovy
await().atMost(10, SECONDS)
    .pollInterval(500, MILLISECONDS)
    .until(() -> getHoldings(userId).size() > 0)
```
- Pros: Industry standard, configurable, handles unpredictable timing
- Cons: Adds dependency (org.awaitility:awaitility-groovy)
- Q/A Estimate: +10-15 tests

**Option B: Increase Fixed Sleep Durations**
```groovy
Thread.sleep(10_000) // Increase from 5s to 10s
```
- Pros: No code changes, simple
- Cons: Tests slower, brittle, doesn't solve root cause
- Estimate: +5-10 tests

**Option C: Kafka Test Containers with Polling**
- Pros: Best practice for integration testing
- Cons: Significant refactoring, higher complexity
- Estimate: High effort, uncertain timeline

**Required:** Choose an option and provide implementation guidance.

**Decision #2: Test Data Isolation Strategy**

Current cleanDatabase() implementation may not be effective:

**Option A: Enhanced Database Cleanup**
```groovy
void cleanDatabase() {
    // Clear all tables in all schemas
    ['user_service', 'wallet_service', 'trading_service', 'portfolio_service', 'transaction_history_service'].each { schema ->
        sql.execute("TRUNCATE TABLE ${schema}.users CASCADE")
        sql.execute("TRUNCATE TABLE ${schema}.wallet_balances CASCADE")
        // ... other tables
    }
    // Reset Kafka consumer offsets
}
```

**Option B: Test Database Reset**
```groovy
@BeforeEach
void setup() {
    resetDatabase()  // Drop and recreate schemas
    resetKafkaTopics()  // Clear all messages
}
```

**Option C: Test-Specific Identifiers**
```groovy
def testId = UUID.randomUUID().toString()
def email = "test-${testId}@example.com"
```

**Required:** Choose an option and provide implementation guidance.

### 3. Technical Recommendations

Based on the Q/A report, please provide:

1. **Recommended Test Timing Approach**
   - Which option (A/B/C) for test timing?
   - Justification based on trade-offs
   - Implementation complexity estimate

2. **Recommended Data Isolation Approach**
   - Which option (A/B/C) for data cleanup?
   - Justification based on trade-offs
   - Implementation complexity estimate

3. **Wallet Integration Investigation**
   - Should Developer verify trading-service → wallet-service API calls?
   - Are there synchronous vs asynchronous concerns?
   - Should we add explicit validation?

4. **Test Suite Organization**
   - Should we separate unit tests vs integration tests?
   - Should we categorize by timing requirements (fast vs slow)?
   - Should we enable parallel test execution?

### 4. Implementation Plan

Provide detailed implementation instructions for the Developer in `docs/08_dev.md`:

**Must Include:**
1. Step-by-step implementation guide
2. Code examples for test timing changes
3. Database cleanup improvements
4. Files to modify (list all integration test specs)
5. Dependencies to add (if any)
6. Testing strategy (how to verify improvements)
7. Expected test results (predict how many tests will pass)

**Target Outcome:**
- 38-42 tests passing (84-93%)
- All Kafka event flow tests passing
- Test suite stable and reliable
- No false negatives or brittle tests

### 5. Risk Assessment

Please assess:
1. **Implementation Risk:** How complex is this change?
2. **Regression Risk:** Could we break currently passing tests?
3. **Timeline:** Estimate of effort required
4. **Token Budget:** Will we stay within 200K budget?

---

## Context from Previous Steps

**Step 07 Achievements:**
- ✅ Trading Service API refactored (4 → 2 endpoints)
- ✅ Critical Kafka bug fixed (Portfolio Service @Blocking annotation)
- ✅ Test improvements (+7 tests from Step 06)
- ✅ Fractional shares: 100% tested
- ✅ Wallet operations: 100% tested
- ✅ Currency exchange: 100% tested

**Step 07 Remaining Issues:**
- ⚠️ Kafka event flows: 0/6 (0%)
- ⚠️ Complete journeys: 1/3 (33%)
- ⚠️ Portfolio tracking: 3/5 (60%)
- ⚠️ User registration: 1/3 (33%)

**Q/A Test Results Breakdown:**
```
✅ Wallet operations: 10/10 (100%)
✅ Currency exchange: 3/3 (100%)
✅ Fractional shares: 4/4 (100%)
✅ Schema isolation: 5/6 (83%)
✅ Buy orders: 3/4 (75%)
✅ Sell orders: 3/4 (75%)
⚠️ Portfolio tracking: 3/5 (60%)
⚠️ User registration: 1/3 (33%)
⚠️ Complete journeys: 1/3 (33%)
❌ Kafka event flows: 0/6 (0%)
```

---

## Files for Reference

**Integration Test Specs (services/integration-tests/src/test/groovy/):**
1. SchemaIsolationSpec.groovy - 5/6 passing
2. WalletDepositSpec.groovy - 3/3 passing ✅
3. WalletWithdrawSpec.groovy - 3/3 passing ✅
4. WalletCurrencyExchangeSpec.groovy - 4/4 passing ✅
5. CurrencyExchangeSpec.groovy - 3/3 passing ✅
6. BuyOrderSpec.groovy - 3/4 passing
7. SellOrderSpec.groovy - 3/4 passing
8. FractionalSharesSpec.groovy - 4/4 passing ✅
9. PortfolioTrackingSpec.groovy - 3/5 passing
10. UserRegistrationSpec.groovy - 1/3 passing
11. CompleteUserJourneySpec.groovy - 1/3 passing
12. KafkaEventFlowSpec.groovy - 0/6 passing ❌

**Test Infrastructure:**
- BaseIntegrationSpec.groovy - Base test class with helpers
- application-test.properties - Test configuration

---

## Success Criteria

Step 08 will be considered successful when:

1. ✅ **Test Coverage:** 38-42 tests passing (84-93%)
2. ✅ **Kafka Event Flows:** At least 4/6 tests passing (67%+)
3. ✅ **Complete Journeys:** At least 2/3 tests passing (67%+)
4. ✅ **No Regressions:** All currently passing tests still pass
5. ✅ **Test Stability:** Tests pass consistently (no flakiness)
6. ✅ **Token Budget:** Stay within 200K total

---

## Next Steps

1. **Senior Engineer:** Review Q/A analysis and make architectural decisions
2. **Senior Engineer:** Create detailed implementation plan in `docs/08_dev.md`
3. **Senior Engineer:** Update `docs/08_discussion.md` with your analysis
4. **Developer:** Implement changes per `docs/08_dev.md`
5. **Q/A:** Validate test improvements reach 89%+ target

---

**Product Owner Sign-Off:** Claude Sonnet 4.5
**Date:** 2026-01-14
**Priority:** HIGH - Core business feature validation
**Expected Duration:** 1 step (Step 08)
**Token Budget:** 149,380 remaining (sufficient)
