# 06_se.md - Senior Engineer: Architecture Refactoring Decision

**Date:** 2026-01-13
**Role:** Senior Engineer
**Step:** 06 - Architectural Refactoring: Merge user-signup-service into user-service
**Context:** Escalation from Step 05 - User validation blocking issue revealed fundamental architecture flaw

---

## Executive Summary

After reviewing the Step 05 validation blocker, I've identified a **fundamental architectural flaw** in the current microservice design. The user-signup-service should not exist as a separate service - all user creation logic belongs in user-service.

**Architectural Decision:** Merge user-signup-service into user-service

**Rationale:** User signup IS user creation. The artificial service separation violates domain boundaries and creates unnecessary complexity.

---

## Problem Analysis

### Current Architecture (Flawed)

```
Client â†’ API Gateway â†’ user-signup-service â†’ Kafka Event â†’ user-service â†’ Database
                       (generates UUID,        (UserCreated)   (consumes event,
                        publishes event)                        stores user)
```

### What's Wrong

#### 1. Violates Domain Boundaries
- **user-service** owns the User domain and all user data
- **user-signup-service** is trying to create users without owning the domain
- User creation (signup) is a core user-service responsibility, not a separate concern

#### 2. Artificial Service Separation
user-signup-service does almost nothing meaningful:
- Validates null checks (trivial)
- Generates UUID (trivial)
- Publishes Kafka event (should be done AFTER persistence)
- Has NO database, NO state, NO business logic

This is "microservice for microservice's sake" - an anti-pattern.

#### 3. Creates the Validation Dilemma
The validation problem we encountered in Step 05 is a **code smell** indicating wrong boundaries:
- Signup needs to validate email doesn't exist
- But signup-service doesn't own user data
- This forces cross-service data access (architectural violation)

#### 4. Incorrect Event Semantics
Current: Event is a **command** ("Create this user")
Correct: Event should be a **notification** ("User was created")

Events should communicate **facts that happened**, not commands to execute.

#### 5. Doesn't Scale to Real-World Requirements

**Key Insight from Operator:** "One user might have many credentials"

In production systems, users have multiple authentication methods:
- Email/password signup
- Phone number signup
- OAuth providers (Google, GitHub, Facebook, etc.)
- Username/password
- SSO/SAML
- Magic links

**All of these are authentication methods for the SAME user domain.**

Having a separate signup-service doesn't make sense when you need to support:
```
POST /users/signup/email
POST /users/signup/phone
POST /users/signup/oauth
POST /users/credentials/{credentialId}
GET  /users/{userId}/credentials
```

These all manipulate the User aggregate - they belong in user-service.

---

## Proposed Architecture (Correct)

```
Client â†’ API Gateway â†’ user-service (POST /api/v1/users) â†’ Database
                       â†“ (after successful persistence)
                       Kafka: UserCreated Event (notification)
                       â†“
                 wallet-service, portfolio-service
                 (react to notification that user exists)
```

### Key Principles

#### 1. True Domain Ownership
- **user-service** owns ALL user operations: create, read, update, delete
- **user-service** owns ALL credentials: email, phone, OAuth tokens
- **user-service** owns ALL validation: format, duplicates, business rules

#### 2. Transactional Integrity
```java
@Transactional
public UserEntity createUser(CreateUserRequest request) {
    // 1. Validate (same service, same database, same transaction)
    validateEmailFormat(request.email);
    if (existsByEmail(request.email)) {
        throw new ConflictException("Email already exists");
    }

    // 2. Save to database
    UserEntity user = new UserEntity();
    user.id = UUID.randomUUID();
    user.email = request.email;
    user.username = request.username;
    user.phoneNumber = request.phoneNumber;
    user.createdAt = Instant.now();
    user.persist();

    // 3. Publish event AFTER commit (notification of fact)
    UserCreatedEvent event = new UserCreatedEvent(user.id, user.email, user.username, user.phoneNumber);
    eventPublisher.publish(event);

    return user;
}
```

All validation happens in a single transaction with the database insert. No cross-service coupling.

#### 3. Event as Notification
The Kafka event is published **AFTER** successful database insert:
- Event communicates a **fact**: "User was created"
- Other services react to this fact (create wallet, create portfolio)
- If user creation fails, no event is published
- Simplified error handling

#### 4. Scalability for Multiple Credential Types
Future expansion is straightforward:
```
user-service/
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ UserEntity.java
â”‚   â”œâ”€â”€ EmailCredential.java
â”‚   â”œâ”€â”€ PhoneCredential.java
â”‚   â”œâ”€â”€ OAuthCredential.java
â”œâ”€â”€ endpoints/
â”‚   â”œâ”€â”€ POST /users (email signup)
â”‚   â”œâ”€â”€ POST /users/oauth (OAuth signup)
â”‚   â”œâ”€â”€ POST /users/phone (phone signup)
â”‚   â”œâ”€â”€ GET  /users/{userId}/credentials
```

---

## Benefits of This Architecture

### 1. Eliminates Validation Problem
âœ… No cross-service data access needed
âœ… Validation happens in same transaction as insert
âœ… Database unique constraints provide safety net
âœ… All business logic in one place

### 2. Simpler Architecture
âœ… Fewer services to maintain (10 â†’ 9)
âœ… Fewer Docker containers
âœ… Fewer failure points
âœ… Easier to reason about

### 3. Better Transactional Guarantees
âœ… Single database transaction for validation + insert
âœ… No race conditions between validation and insert
âœ… Atomic operation: either user is created or not

### 4. Follows Microservice Best Practices
âœ… Service boundaries match domain boundaries
âœ… Each service owns its data completely
âœ… Events are notifications, not commands
âœ… No distributed transactions needed

### 5. Easier Testing
âœ… All user logic tested in one service
âœ… No need to test Kafka event flow for basic validation
âœ… Integration tests are simpler

---

## Migration Strategy

### Phase 1: Add Signup Endpoint to user-service

**File:** `services/user-service/src/main/java/com/trading/platform/user/resource/UserResource.java`

Add new endpoint:
```java
@POST
@Operation(summary = "Create new user", description = "Register a new user with email, username, and phone")
public Response createUser(CreateUserRequest request) {
    try {
        UserEntity user = userService.createUserDirect(request);
        return Response.status(Response.Status.CREATED)
            .entity(Map.of(
                "userId", user.id,
                "email", user.email,
                "username", user.username
            ))
            .build();
    } catch (IllegalArgumentException e) {
        return Response.status(Response.Status.BAD_REQUEST)
            .entity(Map.of("error", e.getMessage()))
            .build();
    } catch (ConflictException e) {
        return Response.status(Response.Status.CONFLICT)
            .entity(Map.of("error", e.getMessage()))
            .build();
    }
}
```

### Phase 2: Add Validation to user-service

**File:** `services/user-service/src/main/java/com/trading/platform/user/service/UserService.java`

Add new method:
```java
private static final Pattern EMAIL_PATTERN = Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");

@Transactional
public UserEntity createUserDirect(CreateUserRequest request) {
    // Validate input
    if (request.email == null || request.email.isBlank()) {
        throw new IllegalArgumentException("Email is required");
    }
    if (request.username == null || request.username.isBlank()) {
        throw new IllegalArgumentException("Username is required");
    }
    if (request.phoneNumber == null || request.phoneNumber.isBlank()) {
        throw new IllegalArgumentException("Phone number is required");
    }

    // Validate email format
    if (!EMAIL_PATTERN.matcher(request.email).matches()) {
        throw new IllegalArgumentException("Invalid email format");
    }

    // Check for duplicates (in same transaction)
    if (UserEntity.existsByEmail(request.email)) {
        throw new ConflictException("Email already registered");
    }
    if (UserEntity.existsByUsername(request.username)) {
        throw new ConflictException("Username already taken");
    }
    if (UserEntity.existsByPhoneNumber(request.phoneNumber)) {
        throw new ConflictException("Phone number already registered");
    }

    // Create user
    UserEntity user = new UserEntity();
    user.id = UUID.randomUUID();
    user.email = request.email;
    user.username = request.username;
    user.phoneNumber = request.phoneNumber;
    user.createdAt = Instant.now();
    user.persist();

    LOG.info("Created user directly: id={}, email={}, username={}",
        user.id, user.email, user.username);

    // Publish event notification (after successful persistence)
    publishUserCreatedEvent(user);

    return user;
}
```

### Phase 3: Add Kafka Producer to user-service

**File:** `services/user-service/build.gradle.kts`

Verify these dependencies exist:
```kotlin
implementation("io.quarkus:quarkus-smallrye-reactive-messaging-kafka")
implementation("io.quarkus:quarkus-kafka-client")
```

**File:** `services/user-service/src/main/resources/application.properties`

Add Kafka producer configuration:
```properties
# Kafka Producer (for publishing UserCreated events)
mp.messaging.outgoing.user-events-out.connector=smallrye-kafka
mp.messaging.outgoing.user-events-out.topic=user-events
mp.messaging.outgoing.user-events-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
```

**File:** `services/user-service/src/main/java/com/trading/platform/user/service/UserService.java`

Add event publisher:
```java
@Inject
@Channel("user-events-out")
Emitter<UserCreatedEvent> userEventsEmitter;

private void publishUserCreatedEvent(UserEntity user) {
    UserCreatedEvent event = new UserCreatedEvent(
        user.id,
        user.email,
        user.username,
        user.phoneNumber
    );

    LOG.info("Publishing UserCreated event for userId={}", user.id);
    userEventsEmitter.send(event);
}
```

### Phase 4: Update API Gateway

**File:** `services/api-gateway/src/main/java/com/trading/platform/apigateway/resource/GatewayResource.java`

Change signup routing:
```java
@POST
@Path("/signup")
@Tag(name = "Gateway")
@Operation(summary = "Register new user")
public Response signup(SignupRequest request) {
    // Change from userSignupClient to userClient
    return userClient.createUser(request);  // Changed line
}
```

**File:** `services/api-gateway/src/main/java/com/trading/platform/apigateway/client/UserClient.java`

Add method:
```java
@POST
@Path("/api/v1/users")
Response createUser(SignupRequest request);
```

### Phase 5: Keep Event Consumer for Backward Compatibility

**Important:** Keep the existing UserEventConsumer in user-service for now.

This allows gradual migration:
- Old flow: signup-service â†’ event â†’ user-service (via consumer)
- New flow: direct POST â†’ user-service â†’ event (notification)

Both flows will work during transition. Once confirmed the new flow works, we can:
1. Remove user-signup-service
2. Keep the event consumer (other services might publish user creation events)
3. Remove event consumer ONLY if we're certain no other services use it

### Phase 6: Remove user-signup-service

**File:** `docker-compose.yml`

Remove the entire user-signup-service section.

**File:** `settings.gradle.kts`

Remove:
```kotlin
include(":services:user-signup-service")
```

**Directory:** `services/user-signup-service/`

Can be deleted entirely after verification.

---

## Testing Strategy

### Phase 1: Unit Tests
Test the new createUserDirect method:
- Valid input â†’ user created
- Invalid email format â†’ 400 error
- Duplicate email â†’ 409 error
- Duplicate username â†’ 409 error
- Duplicate phone â†’ 409 error

### Phase 2: Integration Tests
Test the full flow:
- POST /api/v1/users â†’ user in database â†’ event published â†’ wallet/portfolio created

### Phase 3: Existing Test Compatibility
All existing integration tests should pass:
- User registration tests (2 tests that were failing should now pass)
- Trading tests (dependent on user creation)
- Portfolio tests (dependent on user creation)

**Expected Results:**
- Before: 16/45 tests passing (35.6%)
- After: 40-43/45 tests passing (89-96%)

---

## Risk Assessment

### Low Risk
âœ… User-service already has all the infrastructure (database, entities, queries)
âœ… API Gateway change is a single line
âœ… Event structure remains identical (backward compatible)
âœ… Can test new endpoint before removing old service

### Mitigation
- Implement new endpoint first
- Test thoroughly before removing old service
- Keep event consumer for backward compatibility
- Can roll back by reverting API Gateway routing

---

## Implementation Timeline

**Estimated Time:** 2-3 hours for developer

**Breakdown:**
1. Add POST /users endpoint - 30 minutes
2. Add validation logic - 30 minutes
3. Add Kafka producer - 30 minutes
4. Update API Gateway - 15 minutes
5. Testing - 45 minutes
6. Remove user-signup-service - 15 minutes

---

## Acceptance Criteria

âœ… POST /api/v1/users endpoint works correctly
âœ… Email format validation returns 400 for invalid emails
âœ… Duplicate email returns 409 conflict
âœ… Duplicate username returns 409 conflict
âœ… Duplicate phone returns 409 conflict
âœ… User persisted to database correctly
âœ… UserCreated event published after persistence
âœ… All integration tests pass (target: 40+/45)
âœ… user-signup-service removed from docker-compose
âœ… System works end-to-end

---

## Long-Term Benefits

### Architectural Cleanliness
- Services match domain boundaries
- Each service owns its complete domain
- No artificial service boundaries

### Maintainability
- Fewer services to maintain
- Less code duplication
- Easier to understand system

### Future Expansion
Easy to add:
- OAuth signup (POST /users/oauth)
- Phone signup (POST /users/phone)
- Multiple credentials per user
- Credential management endpoints

### Team Learning
This refactoring demonstrates:
- How to identify architectural code smells
- When to merge services vs. split them
- Event-driven architecture best practices
- Domain-driven design principles

---

## Decision Rationale Summary

**Why This is the Right Architecture:**

1. **Domain Boundary Alignment** - Signup IS user creation, not a separate domain
2. **Operator's Insight** - "One user, many credentials" requires unified user service
3. **Validation Problem** - Code smell indicating wrong service boundary
4. **Microservice Principles** - Services should own their complete domain
5. **Event Semantics** - Events should be notifications, not commands
6. **Production Scalability** - Easier to add OAuth, phone, SSO, etc.

This is not premature optimization or over-engineering. This is **fixing a fundamental architectural mistake** that was creating unnecessary complexity and blocking progress.

---

## Next Steps

**Developer:** Implement the refactoring following the detailed instructions in `docs/06_dev.md`

**Success Criteria:** All integration tests passing, architecture simplified, validation working correctly.

---

**Status:** ðŸ”µ READY FOR IMPLEMENTATION
**Architectural Decision:** APPROVED - Merge user-signup-service into user-service
**Risk Level:** LOW (backward compatible, can be tested incrementally)
**Expected Outcome:** Simpler architecture, validation working, 40+/45 tests passing
